.CODE
PUSH simple_heap_init
CALL
PUSH main
CALL
HALT

simple_heap_init:   RET 0   ; Retorna inmediatamente
simple_malloc:      LOADFP  ; inicializacion del RA
LOADSP
STOREFP ; Finaliza inicializacion del RA
LOADHL  ; hl
DUP  ; hl
PUSH 1  ; 1
ADD ; hl+1
STORE 4 ; Guarda el resultado (el puntero a la primer celda de la region de memoria)
LOAD 3  ; Carga la cantidad de celdas a alojar (parametro debe ser positvo)
ADD
STOREHL ; Mueve el heap limit (h1). Expande el heap
STOREFP
RET 1   ; Retorna elimiando el parametro

.DATA
lblVTA:  DW lblA_getB
.CODE

lblA_constructor: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1


lblA_getB: LOADFP; Apilar el valor del registro
LOADSP  ; Apilar el valor del SP
STOREFP ; Guardar el valor del SP en el FP
RMEM 1  ; Reservamos memoria para el resultado del malloc
PUSH 1; Apilo la cantidad de var de instancia del CIR de A +1 por VT
PUSH simple_malloc  ; La dirección de la rutina para alojar memoria en el heap
CALL    ; Llamo a malloc
DUP ; Para no perder la referencia al nuevo CIR
PUSH lblVTB ; Apilamos la dirección del comienzo de la VT de la clase A
STOREREF 0 ; Guardamos la Referencia a la VT en el CIR que creamos
DUP
PUSH lblB_constructor ; Apilamos la dirección de la rutina del constructor
CALL    ; LLamo al constructor
STORE 4; Nodo Return guardo el valor de retorno en la posicion de retorno
STOREFP; Nodo Return guardo el FP en la posicion de retorno
RET 1; Nodo Return Libero la memoria
FMEM 0
STOREFP ; Almacena el tope de la pila en el registro
RET 1

.DATA
lblVTB:  DW lblB_getC
.CODE

lblB_constructor: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1


lblB_getC: LOADFP; Apilar el valor del registro
LOADSP  ; Apilar el valor del SP
STOREFP ; Guardar el valor del SP en el FP
RMEM 1  ; Reservamos memoria para el resultado del malloc
PUSH 1; Apilo la cantidad de var de instancia del CIR de A +1 por VT
PUSH simple_malloc  ; La dirección de la rutina para alojar memoria en el heap
CALL    ; Llamo a malloc
DUP ; Para no perder la referencia al nuevo CIR
PUSH lblVTC ; Apilamos la dirección del comienzo de la VT de la clase A
STOREREF 0 ; Guardamos la Referencia a la VT en el CIR que creamos
DUP
PUSH lblC_constructor ; Apilamos la dirección de la rutina del constructor
CALL    ; LLamo al constructor
STORE 4; Nodo Return guardo el valor de retorno en la posicion de retorno
STOREFP; Nodo Return guardo el FP en la posicion de retorno
RET 1; Nodo Return Libero la memoria
FMEM 0
STOREFP ; Almacena el tope de la pila en el registro
RET 1

.DATA
lblVTC:  DW lblC_getD
.CODE

lblC_constructor: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1


lblC_getD: LOADFP; Apilar el valor del registro
LOADSP  ; Apilar el valor del SP
STOREFP ; Guardar el valor del SP en el FP
RMEM 1  ; Reservamos memoria para el resultado del malloc
PUSH 1; Apilo la cantidad de var de instancia del CIR de A +1 por VT
PUSH simple_malloc  ; La dirección de la rutina para alojar memoria en el heap
CALL    ; Llamo a malloc
DUP ; Para no perder la referencia al nuevo CIR
PUSH lblVTD ; Apilamos la dirección del comienzo de la VT de la clase A
STOREREF 0 ; Guardamos la Referencia a la VT en el CIR que creamos
DUP
PUSH lblD_constructor ; Apilamos la dirección de la rutina del constructor
CALL    ; LLamo al constructor
STORE 4; Nodo Return guardo el valor de retorno en la posicion de retorno
STOREFP; Nodo Return guardo el FP en la posicion de retorno
RET 1; Nodo Return Libero la memoria
FMEM 0
STOREFP ; Almacena el tope de la pila en el registro
RET 1

.DATA
lblVTD:  DW lblD_compute
.CODE

lblD_constructor: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

lblD_compute: LOADFP; Apilar el valor del registro
LOADSP  ; Apilar el valor del SP
STOREFP ; Guardar el valor del SP en el FP
.DATA
string_label_0: DW "hola", 0
.CODE
PUSH string_label_0
STORE 4; Nodo Return guardo el valor de retorno en la posicion de retorno
STOREFP; Nodo Return guardo el FP en la posicion de retorno
RET 1; Nodo Return Libero la memoria
FMEM 0
STOREFP ; Almacena el tope de la pila en el registro
RET 1


.DATA
lblVTMain:  NOP
.CODE

lblMain_constructor: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1


main: LOADFP; Apilar el valor del registro
LOADSP  ; Apilar el valor del SP
STOREFP ; Guardar el valor del SP en el FP
RMEM 1; Reservo espacio para la variable a
RMEM 1  ; Reservamos memoria para el resultado del malloc
PUSH 1; Apilo la cantidad de var de instancia del CIR de A +1 por VT
PUSH simple_malloc  ; La dirección de la rutina para alojar memoria en el heap
CALL    ; Llamo a malloc
DUP ; Para no perder la referencia al nuevo CIR
PUSH lblVTA ; Apilamos la dirección del comienzo de la VT de la clase A
STOREREF 0 ; Guardamos la Referencia a la VT en el CIR que creamos
DUP
PUSH lblA_constructor ; Apilamos la dirección de la rutina del constructor
CALL    ; LLamo al constructor
STORE 0 ; Guardo el valor de la variable a
RMEM 1; Reservo espacio para la variable result
LOAD 0 ; AccesoVar Cargo la variable a
RMEM 1  ; Guardo lugar para el retorno
SWAP
DUP
LOADREF 0; Apilo el offset de la VT en la CIR (Siempre es 0)
LOADREF 0; Apilo el offset del metodo getB en la VT
CALL    ; Llamar al método getB
RMEM 1  ; Guardo lugar para el retorno
SWAP
DUP
LOADREF 0; Apilo el offset de la VT en la CIR (Siempre es 0)
LOADREF 0; Apilo el offset del metodo getC en la VT
CALL    ; Llamar al método getC
RMEM 1  ; Guardo lugar para el retorno
SWAP
DUP
LOADREF 0; Apilo el offset de la VT en la CIR (Siempre es 0)
LOADREF 0; Apilo el offset del metodo getD en la VT
CALL    ; Llamar al método getD
RMEM 1  ; Guardo lugar para el retorno
SWAP
DUP
LOADREF 0; Apilo el offset de la VT en la CIR (Siempre es 0)
LOADREF 0; Apilo el offset del metodo compute en la VT
CALL    ; Llamar al método compute
STORE -1 ; Guardo el valor de la variable result
PUSH 0
POP
LOAD -1 ; AccesoVar Cargo la variable result
PUSH printSln; Apilar la dirección del método printSln
CALL    ; Llamar al método printSln
FMEM 2
STOREFP ; Almacena el tope de la pila en el registro
RET 0

.DATA
lblVTObject: NOP
.CODE

lblConstructor@Object: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

debugPrint: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
IPRINT  ; Imprime el entero en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

.DATA
lblVTString: NOP
.CODE

lblConstructor@String: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

.DATA
lblVTSystem: NOP
.CODE

lblConstructor@System: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
FMEM 0
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

printC: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
CPRINT  ; Imprime el char en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

printS: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
SPRINT  ; Imprime el string en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

println: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 0

printCln: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
CPRINT  ; Imprime el char en el tope de la pila
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

printSln: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
SPRINT  ; Imprime el booleano en el tope de la pila
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

read: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
READ  ; Lee un valor entero
PUSH 48  ; Por ASCII
SUB
STORE 3  ; Devuelve el valor entero leído, poniendo el tope de la pila en la locación reservada
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 0

printB: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
BPRINT  ; Imprime el booleano en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

printIln: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
IPRINT  ; Imprime el entero en el tope de la pila
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

printI: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
IPRINT  ; Imprime el entero en el tope de la pila
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

printBln: LOADFP  ; Apila el valor del registro fp
LOADSP  ; Apila el valor del registro sp
STOREFP  ; Almacena el tope de la pila en el registro fp
LOAD 3  ; Apila el parámetro
BPRINT  ; Imprime el booleano en el tope de la pila
PRNLN  ; Imprime el caracter de nueva línea
STOREFP  ; Almacena el tope de la pila en el registro fp
RET 1

